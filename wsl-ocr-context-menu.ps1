# Generated by Gemini AI

param([string]$InputPath)

# 1. IMMEDIATE FIX: Move PowerShell off the D: drive to C: 
# This stops the "Failed to translate" error when calling WSL.
$originalLocation = Get-Location
Set-Location "C:\"

if ([string]::IsNullOrWhiteSpace($InputPath)) { exit }

# 1. Setup Variables
$driveLetter = $InputPath[0].ToString().ToLower()
$wslMountPoint = "/mnt/$driveLetter"

# Convert Windows path to a clean Linux string
# Example: D:\Files -> /mnt/d/Files
$relativePath = $InputPath.Substring(3).Replace('\', '/')
$fullWslPath = "$wslMountPoint/$relativePath"

Write-Host "--- Initializing WSL Mount for ${driveLetter}: ---" -ForegroundColor Yellow

# 2. Force the creation of the mount point and perform the mount
# We use 'mkdir -p' to ensure the folder exists, then mount.
# The core WSL command string, enclosed in single quotes for PowerShell to pass literally
# Note: The $USER variable is a Linux environment variable, bash will interpret it.
# The `id -u $USER` and `id -g $USER` will be executed within WSL.
$mountCommand = "sudo mkdir -p $wslMountPoint && sudo mount -t drvfs ${driveLetter}: $wslMountPoint -o uid=`$(id -u),gid=`$(id -g),metadata 2>/dev/null"

wsl bash -c $mountCommand

# 3. Verify the path exists now
$pathExists = wsl bash -c "if [ -d '$fullWslPath' ] || [ -f '$fullWslPath' ]; then echo 'YES'; fi"

if ($pathExists -ne "YES") {
    Write-Host "ERROR: WSL still cannot see the path: $fullWslPath" -ForegroundColor Red
    Write-Host "Please ensure the D: drive is accessible in Windows."
    Start-Sleep -Seconds 10
    exit
}

# 4. Identify files to process
$filesToProcess = @()
if (Test-Path -Path $InputPath -PathType Container) {
    $filesToProcess = Get-ChildItem -Path "$InputPath\*.pdf" | Where-Object { $_.Name -notlike "OCR_*" }
    $workingDir = $fullWslPath
} else {
    $file = Get-Item -Path $InputPath
    $filesToProcess = @($file)
    $workingDir = "$wslMountPoint/" + $file.DirectoryName.Substring(3).Replace('\', '/')
}

# 5. Run OCR
foreach ($pdf in $filesToProcess) {
    $fileName = $pdf.Name
    Write-Host "Processing: $fileName" -ForegroundColor Cyan
    wsl bash -c "cd '$workingDir' && ocrmypdf -l deu --deskew --clean-final --output-type pdfa '$fileName' 'OCR_$fileName' 2>&1"
}

Write-Host "`nDone! Closing in 5 seconds..."
Start-Sleep -Seconds 5